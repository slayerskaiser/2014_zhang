\section{Application QoI and Time Synchronization}

\subsection{Background}
 Questions that we like to answer
through this analysis includes the followings. 1.  What will happen
if timing errors are not bounded - a sample may have very inaccurate
timing value - can we detect this unusual event (or fault)?

2.  What could be the upper bound of timing error versus sample rate
for estimation application - Is there any relationship between
sample rate and timing error (such as if timing errors are high, do
we need more frequent samples?)

3.  Can we do some fault detection and correction. Such as
maintaining history of samples from each sensor, we can detect some
abnormal behaviors/samples? Or among samples from sensors at certain
duration, we can do also some filtering? 4.  If we want to do this
kind of filtering, do we need better time-sync accuracy?

5.  Does the error characteristic known to the filter help the
accuracy of filtering? Let's say, we can provide a fairly accurate
error model, can filter achieve highly accurate tracking?

\subsubsection{Time synchronization error}
 In our paper, we assume that
a sensor is equipped with an internal hardware oscillator that
provides vibration frequency to keep the local clock continuously
running. The vibration frequency will depend on the size, thickness
and cutting edge of a crystal inside the oscillator and the
condition of sensor's surrounding physical environment.

Generally speaking, we have two sources of synchronization errors
for distributed algorithms: (1) local time change due to clock
drift; (2) message delay uncertainty. These two error sources will
differently impact on the synchronization error depending on
the synchronization technique \cite{wsn-timecali}.

Considering a single node, the local clock of a sensor 'X' at
Coordinated Universal Time (UTC) $t$ can be represented as
\cite{timing-error}
\[t_x = a_xt+ t_{0x} + \Drift_x(t),\]
where $a_x$ is the clock skew, i.e., difference between X's oscillator
and the ideal perfect one, and $t_{0x}$ is the initial time offset.
$\Drift_x(t)$ is the clock drift at time $t$. Clock drift changes with
environment. It is an environment-dependent phenomenon and hard to
be modeled accurately. More detailed discussion on clock drift will
be shown in Section \ref{}.

If we consider two nodes, then we also consider message latency and
other communication-related delay. It can be classified as the
followings further \cite{timing-error}.
\begin{itemize}
\item {\bf P}rocessing delay: the time spent at node S (sender) to
prepare and process the packet, and transfer it to the networking
component.
\item {\bf A}ccess delay: the delay to acquire the wireless medium
\item {\bf P}ropagation delay: the delay to transmit the propagate over
the medium
\item {\bf R}eceive delay: time for the node R (receiver) to
process the packet and get the reading of its local clock
\end{itemize}

In total, the delay to include all the communication can be
represented as $PAPR_{StoR}$, and the time of R relative to S can be
shown as $t_r$ = $a_{rs}(n)t_s$ + $t_{0rs}(n)$ + $PAPR_{StoR}$ ,$nT$
$<$ $t$ $<$ $(n+1)T$, where $T$ is the sampling rate, and $a_{rs}$
is the offset difference between R and S. Detailed information can
be found in ~\cite{timing-error}.

Based on this representation, \cite{timing-error} derives the
limitation on errors between any networked two nodes in terms of
value and distribution. The paper showed that the distribution of
limitation of errors is uniform if communication-related delay is
uniformly bounded. The results from the paper are used in our
analysis.

\subsection{Analysis Framework}
\subsubsection{Event Detection Application}
Section 2.2.1.1 Event detection framework Section \\
2.2.1.2 Analysis on performance of event detection versus various
timing error models Section \\
2.2.2 Target Estimation Application Section \\
2.2.2.1 Target Estimation Filtering Algorithm Section \\
2.2.2.2 Analysis on performance of target estimation versus various
timing error models Section

\subsection{Discussion on relationship between time synchronization service and application
QoI}
